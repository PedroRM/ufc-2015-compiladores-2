options{  JAVA_UNICODE_ESCAPE = true;}PARSER_BEGIN(MiniJavaParser)public class MiniJavaParser{  public static void main(String args []) throws ParseException  {    try    {      MiniJavaParser parser = new MiniJavaParser(System.in);      parser.program();      System.out.println("Success.");           }    catch (Exception e)    {      System.out.println("Error.");      System.out.println(e.getMessage());    }  }}PARSER_END(MiniJavaParser)SKIP :{  " "| "\r"| "\t"| "\n"}SPECIAL_TOKEN : /* COMMENTS */{  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < SMALLER : "<" >| < AND : "&&" >| < ASSIGNMENT : "=" >| < EXCL : "!" >| < OP: ("+"|"-"|"*"|"&&"|"<") > }TOKEN : /* SEPARATORS */{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < LBRACK : "[" >| < RBRACK : "]" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >} TOKEN : /*RESERVED WORDS*/{  < RETURN: "return" >| < STATIC : "static" >| < WHILE : "while" >| < VOID : "void" >| < FOR : "for" >| < INT : "int" >| < BOOL : "boolean" >| < IF : "if" > | < ELSE : "else" >| < ENDOFFILE : "EOF" >| < FALSE : "false" >| < TRUE : "true" >}TOKEN :           /*Aqui eu vou colocar os tokens de palavras como class e String*/{             < CLASS: "class" >| < PUBLIC : "public" >| < MAIN : "main" >| < STRING : "String" >| < EXTENDS : "extends" >| < PRINT : "System.out.println" >| < LENGTH : "length" >| < THIS : "this" >| < NEW : "new" >}TOKEN :{  < #DIGIT : [ "0"-"9" ] >| < #LETTER : ["A"-"Z"]|["a"-"z"] > | < NUM : (< DIGIT >)+ >| < ID : (< LETTER >|["_"])(< LETTER >|< DIGIT >|["_"])* >}/********************************************* * THE MINIJAVA LANGUAGE GRAMMAR STARTS HERE * *********************************************/ Program program() :{  MainClass mainClass;  ClassDecl classDecl;  ClassDeclList classDeclList = new ClassDeclList();}{  mainClass = mainClass()  (classDecl = classDecl() {classDeclList.addElement(classDecl);})*  { return new Program(mainClass,cdList); }  /*mainClass() (classDecl())* <EOF>*/}MainClass mainClass() :{  Statement statement;  Token classId;  Token stringId;}{  <CLASS> classId = <ID> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACK> <RBRACK> stringId = <ID> <RPAREN>    <LBRACE> statement = statement() <RBRACE> <RBRACE>  { return new MainClass(new Id(classId.toString()),new Id(stringId.toString()),statement); }}ClassDecl classDecl() :         /*OLHAR ESSA AMANHA*/{  Token classId;  Token superClassId;  MethodDeclList methodDeclList = new MethodDeclList();  VarDeclList varDeclList = new VarDeclList();  VarDecl varDecl;  MethodDecl methodDecl;}{  < CLASS > classId = <ID > ( (<LBRACE >   (varDecl = varDecl() {varDeclList.addElement(varDecl);})*   (methodDecl = methodDecl() {methodDeclList.addElement(methodDecl);})* < RBRACE >)  { return new ClassDeclSimple(new Id(classId.toString()), varDeclList, methodDeclList); } |  (<EXTENDS > superClassId = <ID > <LBRACE >   (varDecl = varDecl() { varDeclList.addElement(varDecl);})*   (methodDecl = methodDecl() { methodDeclList.addElement(methodDecl);})* < RBRACE >)  { return new ClassDeclExtends(new Id(classId.toString()), new Id(superClassId.toString()), varDeclList, methodDeclList);})	/*<CLASS> <ID> (<EXTENDS> <ID>)?                              <LBRACE> (varDecl())* (methodDecl())* <RBRACE>*/}VarDecl varDecl() :{  Type type;  Token varID;}{  type = type() varID = <ID> <SEMICOLON>  { return new VarDecl(type,new Id(varID.toString())); }}MethodDecl methodDecl() :{  Token methodID;  Type t;  FormalList formlist;  StatementList stalist = new StatementList();  Exp e;  VarDecl varDecl;  VarDeclList varlist = new VarDeclList();  Statement statement;}{  <PUBLIC> t = type() methodID = <ID> <LPAREN> formlist = formalList() <RPAREN>    <LBRACE> (LOOKAHEAD(2) varDecl = varDecl() { varlist.addElement(varDecl); })*    (statement = statement() { stalist.addElement(statement); })*     <RETURN> e = exp() <SEMICOLON> <RBRACE>    { return new MethodDecl(t,new Id(methodID.toString()),formalist,varlist,stalist,e); }                /*OLHAR AMANHA*/}FormalList formalList() :{  Type t;  Token formalListId;  Formal formal1;  FormalList formlist = new FormalList();}{  (t = type() formalListId = <ID >  { formal1 = new Formal(t,new Id(formalListId.image)); formlist.addElement(formal1);} (formalRest(formlist))*)   { return formlist;}|  { return formlist;}  /*type() <ID> (formalRest())**/}FormalRest formalRest(FormalList formlist) :{  Token id;  Type tipo;}{  <COMMA> tipo = type() id = <ID>  { formlist.addElement(new Formal(tipo,new Id(id.image))); }}Type type() :{  Token tipo;}{    LOOKAHEAD(2) <INT> <LBRACK> <RBRACK> {return new IntArrayType();}  | <BOOL> {return new BooleanType();}  | <INT> {return new IntegerType();}  | t = <ID> {return new IdType(t.image);}}Statement statement() :{  StatementList sl = new StatementList();  Statement stm1,stm2;  Exp e1,e2;  Token t;}{    (<LBRACE> (stm1 = statement(){sl.addElement(stm1);})* <RBRACE>) {return new Block(sl);}  | (<IF> <LPAREN> e1 = exp() <RPAREN> stm1 = statement() <ELSE> stm2 = statement()) {return new If(e1,stm1,stm2);}  | (<WHILE> <LPAREN> e1 = exp() <RPAREN> stm1 = statement())  {return new While(e1,stm1);}  | (<PRINT> <LPAREN> e1 = exp() <RPAREN> <SEMICOLON>)  {return new Print(e1);}  | (LOOKAHEAD(2) t = <ID> <ASSIGNMENT> e1 = exp() <SEMICOLON>)  {return new Assign(new Id(t.image),e1);}         /*OLHAR AQUI AMANHA!!!!!!!*/  | (t = <ID> <LBRACK> e1 = exp() <RBRACK> <ASSIGNMENT> e2 = exp() <SEMICOLON>) {return new ArrayAssign(new Id(t.image),e1,e2);}}Exp exp() :    /*ACHO QUE VOU TER QUE REFATORAR TUDO AQUI*/{  Exp exp1;  Exp exp2;  Token id1;}{    (id1 = <NUM>  {exp1 = new IntegerLiteral(Integer.parseInt(id1.toString())); return ExpAux(exp1);})   | (<TRUE>  {exp1 = new True(); return ExpAux(exp1);})   | (<FALSE>  { exp1 = new False(); return ExpAux(exp1);})  | (id1 = <ID>  {exp1 = new IdentifierExp(id1.toString()); return ExpAux(exp1);})  | (<NEW> ((<INT> <LBRACK>  exp2 = exp() <RBRACK> {exp1 = new NewArray(exp2); return ExpAux(exp1);})  | (id1 = <ID> <LPAREN> <RPAREN> {exp1 = new NewObject(new Id(id1.toString())); return ExpAux(exp1);})))   | (<THIS>  {exp1 = new This(); return ExpAux(exp1);})  | (<NOT> exp2 = exp() {exp1 = new Not(exp2); return ExpAux(exp1);})  | (<LPAREN> exp1 = exp() <RPAREN> {return ExpAux(exp1);})  /*  expAux() ( op() exp()  | <LBRACK> exp() <RBRACK>   | <DOT> ( <LENGTH> | <ID> <LPAREN> (expList())? <RPAREN> ))?*/  }ExpAux expAux(Exp exp1) :{  ExpList expList;  Exp exp2;  Token op;}{    (op = <OP> exp2 = exp() {if(op.toString().equals("&&")) return new And(exp1,exp2);                             if(op.toString().equals("+")) return new Plus(exp1,exp2);                             if(op.toString().equals("-"))return new Minus(exp1,exp2);                             if(op.toString().equals("*"))return new Times(exp1,exp2);                             if(op.toString().equals("<"))return new LessThan(exp1,exp2);})  | (<LBRACK> exp2 = exp() <RBRACK> {return new ArrayLookup(exp1,exp2);})  | (<DOT> ((<LENGTH> {return new ArrayLength(exp1);})  | (op = <ID> <LPAREN> expList = expList() <RPAREN> { return new Call(exp1,new Id(op.toString()),expList);})))  | {return exp1;}  /*  <FALSE>   | <TRUE>   | <ID>   | <THIS>   | <NUM>   | LOOKAHEAD(2) <NEW> <ID> <LPAREN> <RPAREN>           | <NEW> <INT> <LBRACK> exp() <RBRACK>   | <LPAREN> exp() <RPAREN>  | <EXCL> exp()*/}ExpList expList() :{  Exp e1;  ExpList expList = new ExpList();}{  (e1 = exp() {expList.addElement(e1);} (expRest(expList))* {return expList;})  |  {return expList;}}void expRest() :{  Exp e1;}{  <COMMA> e1 = exp() {expList.addElement(e1);}}/*void op() :{}{    <AND>   | <SMALLER>   | <PLUS>   | <MINUS>   | <MULTIPLY> }*/