options{  JAVA_UNICODE_ESCAPE = true;}PARSER_BEGIN(MiniJavaParser)public class MiniJavaParser{  public static void main(String args []) throws ParseException  {    try    {      MiniJavaParser parser = new MiniJavaParser(System.in);      parser.program();      System.out.println("Success.");           }    catch (Exception e)    {      System.out.println("Error.");      System.out.println(e.getMessage());    }  }}PARSER_END(MiniJavaParser)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < SMALLER : "<" >| < AND : "&&" >| < ASSIGNMENT : "=" >| < EXCL : "!" >}TOKEN : /* SEPARATORS */{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < LBRACK : "[" >| < RBRACK : "]" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >}TOKEN :{  < CONSTANT : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >| < #LETTER : ["A"-"Z"]|["a"-"z"] > | < NUM : (< DIGIT >)+ >| < ID : (< LETTER >|["_"])(< LETTER >|< DIGIT >|["_"])* >} TOKEN : /*RESERVED WORDS*/{  < RETURN: "return " >| < STATIC : "static " >| < WHILE : "while " >| < VOID : "void " >| < FOR : "for " >| < INT : "int " >| < BOOL : "boolean " >| < IF : "if " > | < ELSE : "else " >| < ENDOFFILE : "EOF " >| < FALSE : "false " >| < TRUE : "true " >}TOKEN :           /*Aqui eu vou colocar os tokens de palavras como class e String*/{             < CLASS: "class " >| < PUBLIC : "public " >| < MAIN : "main " >| < STRING : "String " >| < EXTENDS : "extends " >| < PRINT : "System.out.println " >| < LENGTH : "length " >| < THIS : "this " >| < INTLITERAL : "INTEGER LITERAL " >| < NEW : "new " >}/********************************************* * THE MINIJAVA LANGUAGE GRAMMAR STARTS HERE * *********************************************/ void program() :{}{  mainClass() (classDecl())* <EOF>}void mainClass() :{}{  <CLASS> <ID> <LBRACE> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACK> <RBRACK> <ID> <RPAREN>    <LBRACE> statement() <RBRACE> <RBRACE>}void classDecl() :{}{	<CLASS> <ID> (<EXTENDS> <ID>)?                              <LBRACE> (varDecl())* (methodDecl())* <RBRACE>}void varDecl() :{}{  type() <ID> <SEMICOLON>}void methodDecl() :{}{  <PUBLIC> type() <ID> <LPAREN> (formalList())? <RPAREN>    <LBRACE> (LOOKAHEAD(2) varDecl())* (statement())* <RETURN> exp() <SEMICOLON> <RBRACE>     /*PRA QUE PRECISA DESSE LOOKAHEAD????*/}void formalList() :{}{  <COMMA> type() <ID>}void type() :{}{    LOOKAHEAD(2) <INT> <LBRACK> <RBRACK>  | <BOOL>  | <INT>  | <ID>}void statement() :{}{    <LBRACE> (statement())* <RBRACE>  | <IF> <LPAREN> exp() <RPAREN> statement() <ELSE> statement()  | <WHILE> <LPAREN> exp() <RPAREN> statement()  | <PRINT> <LPAREN> exp() <RPAREN> <SEMICOLON>  | LOOKAHEAD(2) <ID> <ASSIGNMENT> exp() <SEMICOLON>  | <ID> <LBRACK> exp() <RBRACK> <ASSIGNMENT> exp() <SEMICOLON>}void exp() :{}{    expAux() ( op() exp()  | <LBRACK> exp() <RBRACK>   | <DOT> ( <LENGTH> | <ID> <LPAREN> (expList())? <RPAREN> ))?  }void expAux() :{}{    <FALSE>   | <TRUE>   | <ID>   | <THIS>   | <INTLITERAL>   | LOOKAHEAD(2) <NEW> <ID> <LPAREN> <RPAREN>         /*ESSA PRODUCAO AQUI PODE ESTAR ERRADA*/  | <NEW> <INT> <LBRACK> exp() <RBRACK>   | <LPAREN> exp() <RPAREN>  | <EXCL> exp()}void expList() :{}{  exp() (expRest())*}void expRest() :{}{  <COMMA> exp()}void op() :{}{    <AND>   | <SMALLER>   | <PLUS>   | <MINUS>   | <MULTIPLY> }